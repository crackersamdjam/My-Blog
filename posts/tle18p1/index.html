<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!" /><meta property="og:locale" content="en" /><meta name="description" content="Introduction TLE 2018-19 P1 - Hello, World! is from an April Fools’ Day contest; it’s not a serious competitive programming problem. If you take a look closely at the sample input, you might figure that the 2 means that there are two test cases and each case is a 28x28 grid of floats. The answers to the cases are 1 and 5 respectively. Now you might think of visualizing these grids:" /><meta property="og:description" content="Introduction TLE 2018-19 P1 - Hello, World! is from an April Fools’ Day contest; it’s not a serious competitive programming problem. If you take a look closely at the sample input, you might figure that the 2 means that there are two test cases and each case is a 28x28 grid of floats. The answers to the cases are 1 and 5 respectively. Now you might think of visualizing these grids:" /><link rel="canonical" href="https://ericpei.ca/posts/tle18p1/" /><meta property="og:url" content="https://ericpei.ca/posts/tle18p1/" /><meta property="og:site_name" content="Eric Pei" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-21T16:00:00-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-12-05T16:08:28-05:00","datePublished":"2021-08-21T16:00:00-04:00","description":"Introduction TLE 2018-19 P1 - Hello, World! is from an April Fools’ Day contest; it’s not a serious competitive programming problem. If you take a look closely at the sample input, you might figure that the 2 means that there are two test cases and each case is a 28x28 grid of floats. The answers to the cases are 1 and 5 respectively. Now you might think of visualizing these grids:","headline":"Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!","mainEntityOfPage":{"@type":"WebPage","@id":"https://ericpei.ca/posts/tle18p1/"},"url":"https://ericpei.ca/posts/tle18p1/"}</script><title>Machine Learning on a DMOJ problem: TLE18P1 - Hello, World! | Eric Pei</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Eric Pei"><meta name="application-name" content="Eric Pei"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Eric Pei</a></div><div class="site-subtitle font-italic">crackersamdjam</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/crackersamdjam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/crackersamdjam/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://keybase.io/crackersamdjam" aria-label="keybase" target="_blank" rel="noopener"> <i class="fab fa-keybase"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['me','ericpei.ca'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1629576000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 21, 2021 </em> </span> <span> Updated <em class="" data-ts="1638738508" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Dec 5, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/crackersamdjam">Eric Pei</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1545 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://dmoj.ca/problem/tle18p1">TLE 2018-19 P1 - Hello, World!</a> is from an April Fools’ Day contest; it’s not a serious competitive programming problem. If you take a look closely at the sample input, you might figure that the <code class="language-plaintext highlighter-rouge">2</code> means that there are two test cases and each case is a 28x28 grid of floats. The answers to the cases are <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">5</code> respectively. Now you might think of visualizing these grids:</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
	<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">28</span><span class="p">)]</span>
	<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">'binary'</span><span class="p">)</span>
	<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</pre></table></code></div></div><div class="table-wrapper"><table><tbody><tr><td><img data-src="/assets/img/content/tle-hello-world/digit_1.png" alt="Digit 1" data-proofer-ignore><td><img data-src="/assets/img/content/tle-hello-world/digit_2.png" alt="Digit 2" data-proofer-ignore></table></div><p>Aha! They’re hand-drawn digits! So that’s what the chalkboard image was about.</p><p>If you search up <a href="https://duckduckgo.com/?q=classifying+hand+drawn+digits">“classifying hand drawn digits,”</a> you’ll find that this is a classical machine learning problem. It’s called the “Hello World” of ML.</p><p>To solve this problem, we need a neural network to classify the input digits. The problem statement doesn’t say what accuracy is needed, but users commented that we need 95% accuracy to get full marks. If you aren’t familiar with neural networks, 3Blue1Brown does a good job explaining it <a href="https://www.3blue1brown.com/topics/neural-networks">here</a>.</p><h2 id="how-to-solve-it-on-dmoj"><span class="mr-2">How to solve it on DMOJ</span><a href="#how-to-solve-it-on-dmoj" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>We can’t import an NN from a DMOJ submission, so we’ll need to write our own neural network. The feed-forward needs to be written by hand, but we don’t have to write code to trains our model. We could train it elsewhere and export the edge weights, but I wanted to test my understanding and implementation skills, so I decided to do it from scratch. Well, not exactly from scratch… I got my training data from <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>.</p><p>After extracting the gzip archives and converting the binary files to plaintext, we can train. My first (working) neural network was something like this:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
#define all(x) (x).begin(), (x).end()
</span>
<span class="cp">#ifdef LOCAL
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="nf">pr</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">){</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">pr</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">,</span><span class="n">pr</span><span class="p">(</span><span class="n">args</span><span class="p">...);}</span>
<span class="cp">#else
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="kt">void</span> <span class="n">pr</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">){}</span>
<span class="cp">#endif
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vd</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vvd</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vd</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">vvvd</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vvd</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">mt19937_64</span> <span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">randf</span><span class="p">(</span><span class="kt">double</span> <span class="n">l</span><span class="p">,</span> <span class="kt">double</span> <span class="n">r</span><span class="p">){</span><span class="k">return</span> <span class="n">uniform_real_distribution</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)(</span><span class="n">g</span><span class="p">);}</span>

<span class="k">struct</span> <span class="nc">neural_network</span><span class="p">{</span>

	<span class="n">vvvd</span> <span class="n">edge_weight</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">layer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">layercnt</span><span class="p">;</span>
	<span class="kt">double</span> <span class="k">const</span> <span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>

	<span class="kt">double</span> <span class="n">sigmoid</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="kt">double</span> <span class="n">derivative_sigmoid</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="kt">double</span> <span class="n">cost</span><span class="p">(</span><span class="n">vd</span> <span class="n">answer</span><span class="p">,</span> <span class="n">vd</span> <span class="n">output</span><span class="p">){</span>
		<span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">(</span><span class="n">answer</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="n">x</span> <span class="o">+=</span> <span class="p">(</span><span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">bool</span> <span class="n">correct</span><span class="p">(</span><span class="n">vd</span> <span class="n">answer</span><span class="p">,</span> <span class="n">vd</span> <span class="n">output</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">max_element</span><span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">answer</span><span class="p">))</span><span class="o">-</span><span class="n">answer</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">max_element</span><span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">output</span><span class="p">))</span><span class="o">-</span><span class="n">output</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">_l</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">:</span> <span class="n">_l</span><span class="p">)</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">layer</span> <span class="o">=</span> <span class="n">_l</span><span class="p">;</span>
		<span class="n">layercnt</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
		
		<span class="n">edge_weight</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			
			<span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>

				<span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
				
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
					<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">j</span><span class="p">)</span>
						<span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">k</span><span class="p">)</span>
						<span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">randf</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pair</span><span class="o">&lt;</span><span class="n">vvd</span><span class="p">,</span> <span class="n">vvd</span><span class="o">&gt;</span> <span class="n">run</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">input</span><span class="p">){</span>
		<span class="n">vvd</span> <span class="n">values</span><span class="p">(</span><span class="n">layercnt</span><span class="p">),</span> <span class="n">values_after_sigmoid</span><span class="p">(</span><span class="n">layercnt</span><span class="p">);</span>
		<span class="n">input</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// bias</span>

		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">layercnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="o">==</span> <span class="n">layer</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>

		<span class="n">values_after_sigmoid</span> <span class="o">=</span> <span class="n">values</span><span class="p">;</span>
		
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">layercnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>

				<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">values_after_sigmoid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="mi">254</span><span class="p">;</span>
				<span class="k">else</span> <span class="n">values_after_sigmoid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>

				<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">layercnt</span><span class="p">){</span>
					<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
						<span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">values_after_sigmoid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="p">{</span><span class="n">values</span><span class="p">,</span> <span class="n">values_after_sigmoid</span><span class="p">};</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">train</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vd</span><span class="p">,</span> <span class="n">vd</span><span class="o">&gt;&gt;</span> <span class="n">tests</span><span class="p">){</span>
		<span class="n">vvvd</span> <span class="n">gradient</span><span class="p">;</span>

		<span class="n">gradient</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="n">gradient</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">j</span><span class="o">:</span> <span class="n">gradient</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
				<span class="n">j</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="p">[</span><span class="n">input</span><span class="p">,</span> <span class="n">answer</span><span class="p">]</span><span class="o">:</span> <span class="n">tests</span><span class="p">){</span>
			<span class="k">auto</span> <span class="p">[</span><span class="n">values</span><span class="p">,</span> <span class="n">values_after_sigmoid</span><span class="p">]</span> <span class="o">=</span> <span class="n">run</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
			<span class="n">input</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">answer</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">answer</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

			<span class="n">vvd</span> <span class="n">node_derivatives</span><span class="p">;</span>
			<span class="n">node_derivatives</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">layercnt</span><span class="p">);</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">layercnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
				<span class="n">node_derivatives</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
				<span class="n">node_derivatives</span><span class="p">[</span><span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">values_after_sigmoid</span><span class="p">[</span><span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">answer</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>

					<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">derivative_sigmoid</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">*</span><span class="n">node_derivatives</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>

					<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
						<span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
						<span class="n">gradient</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="o">*</span><span class="n">values_after_sigmoid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
						<span class="n">node_derivatives</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">d</span><span class="o">*</span><span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="kt">int</span> <span class="n">testcnt</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">tests</span><span class="p">);</span>
	
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">layercnt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">layer</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
					<span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
					<span class="n">edge_weight</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gradient</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">learning_rate</span><span class="o">/</span><span class="n">testcnt</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>I treated the 0th node in each layer as a dummy source for biases. All edges going into dummy nodes had a weight of 0 except for the one coming from the bias of the previous row, which had a value of 1. I also added a 0th dummy node in the input layer that always had a value of 1, so that it would feed all the biases.</p><h2 id="dmojs-source-code-character-limit"><span class="mr-2">DMOJ’s source code character limit</span><a href="#dmojs-source-code-character-limit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>It took a lot of debugging to get my model to work. I then had to face the 64k character limit on DMOJ. My original neural network needed 223k characters to store its edges. I decided to do a 5x5 convolution and 2x2 max pooling in order to shrink my input layer from 28x28 to 12x12 nodes. My new model only needs 45k characters. Plus, it also takes less time to train.</p><p>Another way to get around the character limit is to do data compression.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="n">vvd</span> <span class="nf">convolution</span><span class="p">(</span><span class="n">vvd</span> <span class="n">pre</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">pre</span><span class="p">);</span>
	<span class="n">vvd</span> <span class="n">cur</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">sz</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">vd</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">sz</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="n">sz</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="n">sz</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">){</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">){</span>
					<span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">x</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="n">y</span><span class="p">]</span><span class="o">/</span><span class="n">sz</span><span class="o">/</span><span class="n">sz</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vvd</span> <span class="n">max_pooling</span><span class="p">(</span><span class="n">vvd</span> <span class="n">pre</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="n">pre</span><span class="p">);</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">k</span><span class="p">;</span>
	<span class="n">vvd</span> <span class="n">cur</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">vd</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">){</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">){</span>
					<span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">cur</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">x</span><span class="p">][</span><span class="n">j</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">y</span><span class="p">]);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vd</span> <span class="n">flatten</span><span class="p">(</span><span class="n">vvd</span> <span class="n">pre</span><span class="p">){</span>
	<span class="n">vd</span> <span class="n">cur</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span> <span class="n">pre</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">j</span><span class="o">:</span> <span class="n">i</span><span class="p">){</span>
			<span class="n">cur</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pair</span><span class="o">&lt;</span><span class="n">vd</span><span class="p">,</span> <span class="n">vd</span><span class="o">&gt;</span> <span class="n">read_and_convolute</span><span class="p">(</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">){</span>
	<span class="n">vd</span> <span class="n">ans</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">x</span><span class="p">;</span>
	<span class="n">ans</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vvd</span> <span class="n">cur</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="n">vd</span><span class="p">(</span><span class="mi">28</span><span class="p">));</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span><span class="o">:</span> <span class="n">cur</span><span class="p">){</span>
		<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">j</span><span class="o">:</span> <span class="n">i</span><span class="p">){</span>
			<span class="n">in</span><span class="o">&gt;&gt;</span><span class="n">j</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">convolution</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">max_pooling</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">{</span><span class="n">ans</span><span class="p">,</span> <span class="n">flatten</span><span class="p">(</span><span class="n">cur</span><span class="p">)};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>I could now create a random model and export it to a file.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">create_nn</span><span class="p">(){</span>
	<span class="n">neural_network</span> <span class="n">nn</span><span class="p">;</span>
	<span class="n">nn</span><span class="p">.</span><span class="n">init</span><span class="p">({</span><span class="mi">12</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">});</span>
	<span class="n">nn</span><span class="p">.</span><span class="n">export_edges</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>And I repeatedly improved my model with <code class="language-plaintext highlighter-rouge">run()</code>:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">run</span><span class="p">(){</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vd</span><span class="p">,</span> <span class="n">vd</span><span class="o">&gt;&gt;</span> <span class="n">train_set</span><span class="p">,</span> <span class="n">test_set</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="c1">// 60000 in train set</span>
	<span class="c1">// 10000 in test set</span>

	<span class="n">ifstream</span> <span class="n">train_input</span><span class="p">(</span><span class="s">"mnist_train.txt"</span><span class="p">);</span>
	<span class="n">train_input</span><span class="p">.</span><span class="n">exceptions</span><span class="p">(</span><span class="n">ifstream</span><span class="o">::</span><span class="n">failbit</span> <span class="o">|</span> <span class="n">ifstream</span><span class="o">::</span><span class="n">badbit</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">60000</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">){</span>
		<span class="k">auto</span> <span class="p">[</span><span class="n">answer</span><span class="p">,</span> <span class="n">input</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_and_convolute</span><span class="p">(</span><span class="n">train_input</span><span class="p">);</span>
		<span class="n">train_set</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">input</span><span class="p">,</span> <span class="n">answer</span><span class="p">});</span>
	<span class="p">}</span>
	<span class="n">train_input</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

	<span class="n">neural_network</span> <span class="n">nn</span><span class="p">;</span>
	<span class="n">nn</span><span class="p">.</span><span class="n">import_edges</span><span class="p">();</span>
	
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">100000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
			<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"i "</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">size</span><span class="p">(</span><span class="n">train_set</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="p">{</span><span class="n">train_set</span><span class="p">[</span><span class="n">j</span><span class="p">]};</span>
		<span class="n">nn</span><span class="p">.</span><span class="n">train</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="n">nn</span><span class="p">.</span><span class="n">export_edges</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Each time it finished training, I made a DMOJ submission to see what my accuracy was. I spent about one hour training in total.</p><p>It took me a long time to come up with workable parameters. I settled on <code class="language-plaintext highlighter-rouge">0.01</code> as my learning rate. I tried doing k-fold cross-validation and training in epochs (with the entire test set), but those methods trained slower than my method of randomly picking 20,000,000 images to use.</p><p>There’s a lot more I can do to optimize my code, but the asymptotically worst parts, namely the feed-forward and backpropagation, were good enough.</p><h2 id="conclusion"><span class="mr-2">Conclusion</span><a href="#conclusion" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>By coding up an NN by hand, I found gaps in my understanding. This exercise got me to think through every step of my algorithm and how I should tweak my constants. There’s still more I’d like to explore. For example, when I initially used ReLU, I struggled to address exploding gradients. Once again, I obviously won’t write scrappy NNs by hand in the future; this was just a exercise. I hope to bring you more fun content in the future. Bye! 👋</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/competitive-programming/'>Competitive Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >Algorithm</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/contest-history/">My Contest History</a><li><a href="/posts/tle18p1/">Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!</a><li><a href="/posts/what-is-this/">What is this?</a><li><a href="/posts/cco-2020/">CCO 2020</a><li><a href="/posts/segment-tree/">Comparing 2N and 4N-sized recursive segment trees</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/ccc/">CCC</a> <a class="post-tag" href="/tags/cco/">CCO</a> <a class="post-tag" href="/tags/investigation/">Investigation</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/segment-tree/"><div class="card-body"> <em class="small" data-ts="1625754768" data-df="ll" > Jul 8, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Comparing 2N and 4N-sized recursive segment trees</h3><div class="text-muted small"><p> Introduction When you implement a recursive segment tree, it’s better to store segment tree nodes in an array or vector than it is to create a new object for every node one by one. This reduces th...</p></div></div></a></div><div class="card"> <a href="/posts/codebook/"><div class="card-body"> <em class="small" data-ts="1625521402" data-df="ll" > Jul 5, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My (ICPC) Codebook</h3><div class="text-muted small"><p> In the ICPC (International Collegiate Programming Contest), each team is allowed to bring up to 25 pages of printed material. There are many great codebooks out there such as KACTL, but I prefer to...</p></div></div></a></div><div class="card"> <a href="/posts/cco-2020/"><div class="card-body"> <em class="small" data-ts="1625414170" data-df="ll" > Jul 4, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CCO 2020</h3><div class="text-muted small"><p> My Experience Note: I am writing this blog in June 2021, after the 2021 (not 2020) CCO. 2020 was my first time at the Canadian Computing Olympiad (CCO). The top 25 or so high school students fro...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/segment-tree/" class="btn btn-outline-primary" prompt="Older"><p>Comparing 2N and 4N-sized recursive segment trees</p></a><div class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></div></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/crackersamdjam">Eric Pei</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/ccc/">CCC</a> <a class="post-tag" href="/tags/cco/">CCO</a> <a class="post-tag" href="/tags/investigation/">Investigation</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
