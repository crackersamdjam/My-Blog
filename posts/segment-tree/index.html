<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Comparing 2N and 4N-sized recursive segment trees" /><meta property="og:locale" content="en" /><meta name="description" content="Introduction" /><meta property="og:description" content="Introduction" /><link rel="canonical" href="https://ericpei.ca/posts/segment-tree/" /><meta property="og:url" content="https://ericpei.ca/posts/segment-tree/" /><meta property="og:site_name" content="Eric Pei" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-07-08T10:32:48-04:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Comparing 2N and 4N-sized recursive segment trees" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-07-08T15:40:43-04:00","datePublished":"2021-07-08T10:32:48-04:00","description":"Introduction","headline":"Comparing 2N and 4N-sized recursive segment trees","mainEntityOfPage":{"@type":"WebPage","@id":"https://ericpei.ca/posts/segment-tree/"},"url":"https://ericpei.ca/posts/segment-tree/"}</script><title>Comparing 2N and 4N-sized recursive segment trees | Eric Pei</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Eric Pei"><meta name="application-name" content="Eric Pei"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Eric Pei</a></div><div class="site-subtitle font-italic">crackersamdjam</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/crackersamdjam" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://www.linkedin.com/in/crackersamdjam/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://keybase.io/crackersamdjam" aria-label="keybase" target="_blank" rel="noopener"> <i class="fab fa-keybase"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['me','ericpei.ca'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Comparing 2N and 4N-sized recursive segment trees</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Comparing 2N and 4N-sized recursive segment trees</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1625754768" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 8, 2021 </em> </span> <span> Updated <em class="" data-ts="1625773243" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 8, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/crackersamdjam">Eric Pei</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1043 words"> <em>5 min</em> read</span></div></div></div><div class="post-content"><h2 id="introduction"><span class="mr-2">Introduction</span><a href="#introduction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>When you implement a recursive segment tree, it’s better to store segment tree nodes in an array or vector than it is to create a new object for every node one by one. This reduces the time it takes to create the nodes and it improves caching since the nodes are in a contiguous chunk of memory.</p><h2 id="4n-implementation"><span class="mr-2">4N implementation</span><a href="#4n-implementation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>If you have <code class="language-plaintext highlighter-rouge">vector&lt;node&gt; nodes</code>, you might make <code class="language-plaintext highlighter-rouge">nodes[1]</code> the root node and for every node <code class="language-plaintext highlighter-rouge">x</code>, make its left and right children <code class="language-plaintext highlighter-rouge">2x</code> and <code class="language-plaintext highlighter-rouge">2x+1</code> respectively. Another way might be to have <code class="language-plaintext highlighter-rouge">node[0]</code> as the root and have <code class="language-plaintext highlighter-rouge">2x+1</code> and <code class="language-plaintext highlighter-rouge">2x+2</code> as the children of node <code class="language-plaintext highlighter-rouge">x</code>.</p><p>Either way of indexing uses $2N-1$ nodes when the segment tree is a perfect binary tree, which happens when $N$ is a power of $2$. Otherwise, we should give the tree $2 \cdot 2^{\left \lceil \log_2 N \right \rceil}$ nodes to be safe. This is because even though only $2N-1$ nodes are actually used, some indices of <code class="language-plaintext highlighter-rouge">nodes</code> are skipped. For convenience, we can bound this by $4N$. Our code could look something like this:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#define nm ((nl+nr)/2)
</span>
<span class="kt">int</span> <span class="n">SZ</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// or whatever number you need</span>

<span class="k">struct</span> <span class="nc">node</span><span class="p">{</span>
	<span class="c1">// content</span>
<span class="p">};</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">SZ</span><span class="p">);</span>

<span class="c1">// each node nodes[rt] covers the interval [nl, nr]</span>
<span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">nl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">SZ</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">){</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nl</span> <span class="o">==</span> <span class="n">nr</span><span class="p">){</span>
		<span class="c1">// initialize nodes[rt]</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">build</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">rt</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">build</span><span class="p">(</span><span class="n">nm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">rt</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="2n-implementations"><span class="mr-2">2N implementations</span><a href="#2n-implementations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>One way to create a recursive segment tree with exactly $2n-1$ nodes is to create new nodes as we need them. As mentioned at the start, this performs far worse than the implementation with a vector of size $4n$. However, it will help us reach a solution that uses $2n$ memory. The code might look something like this:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#define nm ((nl+nr)/2)
</span>
<span class="k">struct</span> <span class="nc">node</span><span class="p">{</span>
	<span class="c1">// content</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="o">*</span><span class="n">rc</span><span class="p">;</span>
	<span class="c1">// lc is pointer to left child, rc is pointer to right child</span>
<span class="p">};</span>

<span class="c1">// returns a pointer to the node that covers the interval [nl, nr]</span>
<span class="n">node</span><span class="o">*</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">nl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">){</span>
	<span class="n">node</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="p">();</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nl</span> <span class="o">==</span> <span class="n">nr</span><span class="p">)</span> <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">lc</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="n">cur</span><span class="o">-&gt;</span><span class="n">rc</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We could speed this up by creating all our nodes in advance like so:</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#define nm ((nl+nr)/2)
</span>
<span class="kt">int</span> <span class="n">SZ</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">node</span><span class="p">{</span>
	<span class="c1">// content</span>
	<span class="kt">int</span> <span class="n">lc</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="c1">// left child is nodes[lc]</span>
	<span class="c1">// right child is nodes[rc]</span>
<span class="p">};</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">(</span><span class="n">SZ</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">nl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pr</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nl</span> <span class="o">==</span> <span class="n">nr</span><span class="p">){</span>
		<span class="c1">// initialize nodes[ptr]</span>
		<span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">lc</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">nm</span><span class="p">);</span>
	<span class="n">nodes</span><span class="p">[</span><span class="n">cur</span><span class="p">].</span><span class="n">rc</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">nm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="n">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Notice that when we are at node <code class="language-plaintext highlighter-rouge">cur</code>, we will assign the indices of <code class="language-plaintext highlighter-rouge">nodes</code> first to the left subtree, then to the right subtree. Since our recursive algorithm uses $2N’-1$ nodes to cover an interval of size $N’$, we will give the left subtree the next $2(nm-nl+1)$ nodes and give the following ones to the right subtree. This is almost the same as our original code, the only difference being how we index our nodes. This speeds up our code and uses less memory than <strong>the previous 2N implementation</strong> since we don’t need to store and check what our left and right children are.</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#define nm ((nl+nr)/2)
</span>
<span class="kt">int</span> <span class="n">SZ</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">node</span><span class="p">{</span>
	<span class="c1">// content</span>
<span class="p">};</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">nodes</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">SZ</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">nl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">SZ</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
	<span class="n">pr</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">rt</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nl</span> <span class="o">==</span> <span class="n">nr</span><span class="p">){</span>
		<span class="c1">// initialize nodes[rt]</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">build</span><span class="p">(</span><span class="n">nl</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">rt</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">build</span><span class="p">(</span><span class="n">nm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">rt</span><span class="o">+</span><span class="p">(</span><span class="n">nm</span><span class="o">-</span><span class="n">nl</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="benchmarks"><span class="mr-2">Benchmarks</span><a href="#benchmarks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The question remains: is this faster than our original 4N implementation? <strong>No.</strong> In <a href="https://judge.yosupo.jp/problem/point_set_range_composite">practice</a>, the 4N implementation is faster.</p><div class="table-wrapper"><table><thead><tr><th>Testcase<th><a href="https://judge.yosupo.jp/submission/52577">2N Segment Tree</a><th><a href="https://judge.yosupo.jp/submission/52576">4N Segment Tree</a><tbody><tr><td>example_00<td>1 ms / 0.70 MB<td>1 ms / 0.61 MB<tbody><tr><td>max_random_00<td>666 ms / 18.33 MB<td>653 ms / 19.11 MB<tbody><tr><td>max_random_01<td>667 ms / 18.34 MB<td>649 ms / 19.09 MB<tbody><tr><td>max_random_02<td>658 ms / 18.33 MB<td>654 ms / 19.09 MB<tbody><tr><td>max_random_03<td>660 ms / 18.34 MB<td>652 ms / 19.08 MB<tbody><tr><td>max_random_04<td>662 ms / 18.34 MB<td>653 ms / 19.09 MB<tbody><tr><td>random_00<td>519 ms / 14.46 MB<td>526 ms / 18.59 MB<tbody><tr><td>random_01<td>562 ms / 16.73 MB<td>560 ms / 18.71 MB<tbody><tr><td>random_02<td>274 ms / 4.10 MB<td>281 ms / 4.46 MB<tbody><tr><td>random_03<td>201 ms / 13.85 MB<td>203 ms / 16.84 MB<tbody><tr><td>random_04<td>198 ms / 9.59 MB<td>199 ms / 17.21 MB<tbody><tr><td>small_00<td>1 ms / 0.71 MB<td>1 ms / 0.71 MB<tbody><tr><td>small_01<td>1 ms / 0.71 MB<td>1 ms / 0.71 MB<tbody><tr><td>small_02<td>1 ms / 0.62 MB<td>1 ms / 0.71 MB<tbody><tr><td>small_03<td>1 ms / 0.71 MB<td>1 ms / 0.71 MB<tbody><tr><td>small_04<td>1 ms / 0.71 MB<td>1 ms / 0.71 MB</table></div><p>We already knew that we save up to half our memory by switching to the 2N implementation. Here is a graph of how large our vector <code class="language-plaintext highlighter-rouge">nodes</code> actually needs to be for each of our implementations. For the 4N implementation, our allocation of $2 \cdot 2^{\left \lceil \log_2 N \right \rceil}$ nodes was only an upper bound, albeit a reasonable one. It’s satisfying to see the 4N graph turn into a staircase as N gets large.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center">Memory Usage graph from 1 to 100<th style="text-align: center">Memory Usage Graph from 1 to 1,000,000<tbody><tr><td style="text-align: center"><img data-src="/assets/img/content/segment-tree/100.png" alt="100" data-proofer-ignore><td style="text-align: center"><img data-src="/assets/img/content/segment-tree/1000000.png" alt="100" data-proofer-ignore></table></div><h2 id="conclusions"><span class="mr-2">Conclusions</span><a href="#conclusions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The 2N implementation uses less memory and the 4N implementation is a little faster. These small differences will not matter if the problems you are solving have reasonable time and memory limits.</p><p>Now of course, we could just use iterative segment trees. <del>I guess this blog post was useless (perhaps I should have discussed “walking” on an iterative segment tree instead).</del> ☹️</p><p>I will soon be investigating the feasibility of using “fat nodes” in segment trees. Stay tuned! 📻</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/competitive-programming/'>Competitive Programming</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >Algorithm</a> <a href="/tags/investigation/" class="post-tag no-text-decoration" >Investigation</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/contest-history/">My Contest History</a><li><a href="/posts/tle18p1/">Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!</a><li><a href="/posts/what-is-this/">What is this?</a><li><a href="/posts/cco-2020/">CCO 2020</a><li><a href="/posts/segment-tree/">Comparing 2N and 4N-sized recursive segment trees</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/ccc/">CCC</a> <a class="post-tag" href="/tags/cco/">CCO</a> <a class="post-tag" href="/tags/investigation/">Investigation</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/tle18p1/"><div class="card-body"> <em class="small" data-ts="1629576000" data-df="ll" > Aug 21, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!</h3><div class="text-muted small"><p> Introduction TLE 2018-19 P1 - Hello, World! is from an April Fools’ Day contest; it’s not a serious competitive programming problem. If you take a look closely at the sample input, you might figure...</p></div></div></a></div><div class="card"> <a href="/posts/codebook/"><div class="card-body"> <em class="small" data-ts="1625521402" data-df="ll" > Jul 5, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My (ICPC) Codebook</h3><div class="text-muted small"><p> In the ICPC (International Collegiate Programming Contest), each team is allowed to bring up to 25 pages of printed material. There are many great codebooks out there such as KACTL, but I prefer to...</p></div></div></a></div><div class="card"> <a href="/posts/cco-2020/"><div class="card-body"> <em class="small" data-ts="1625414170" data-df="ll" > Jul 4, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>CCO 2020</h3><div class="text-muted small"><p> My Experience Note: I am writing this blog in June 2021, after the 2021 (not 2020) CCO. 2020 was my first time at the Canadian Computing Olympiad (CCO). The top 25 or so high school students fro...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/codebook/" class="btn btn-outline-primary" prompt="Older"><p>My (ICPC) Codebook</p></a> <a href="/posts/tle18p1/" class="btn btn-outline-primary" prompt="Newer"><p>Machine Learning on a DMOJ problem: TLE18P1 - Hello, World!</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/crackersamdjam">Eric Pei</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/ccc/">CCC</a> <a class="post-tag" href="/tags/cco/">CCO</a> <a class="post-tag" href="/tags/investigation/">Investigation</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
